package bind

import (
	"github.com/pterm/pterm"
	"os"
	"strings"
)

func Generate(basePath string, binds []interface{}) {
	pterm.Info.Println("Generating bind files")
	bindItems := buildBindItems(binds)

	generateFiles := make(map[string]string)

	for _, bindItem := range bindItems {
		path := bindItem.Path
		if bindItem.StructName != "" {
			path += "." + bindItem.StructName
		} else {
			path += "." + "App"
		}

		tsStr := `export function ` + bindItem.MethodName + `(arg1:string):Promise<string>;` + "\n"
		appendGenerateFile(generateFiles, strings.ReplaceAll(path, ".", "/")+".d.ts", tsStr)

		pathArr := strings.Split(bindItem.GetFullName(), ".")
		callStr := ""
		for _, s := range pathArr {
			callStr += "['" + s + "']"
		}
		jsStr := `export function ` + bindItem.MethodName + `(arg1) {
	return window['_cgui']` + callStr + `(arg1);
}` + "\n"
		appendGenerateFile(generateFiles, strings.ReplaceAll(path, ".", "/")+".js", jsStr)
	}

	// 写入文件
	for path, content := range generateFiles {
		// 如果文件夹不存在则创建
		fullPath := basePath + "/bindjs/" + path
		// 判断文件夹是否存在
		_, err := os.Stat(fullPath[:strings.LastIndex(fullPath, "/")])
		if err != nil {
			err := os.MkdirAll(fullPath[:strings.LastIndex(fullPath, "/")], os.ModePerm)
			if err != nil {
				pterm.Error.Println("Write file error: ", err)
				continue
			}
		}
		err = os.WriteFile(fullPath, []byte(content), 0644)
		if err != nil {
			pterm.Error.Println("Write file error: ", err)
		}
	}

	pterm.Info.Println("Generating bind files: Done!", basePath+"/bindjs/")
}

func appendGenerateFile(generateFiles map[string]string, path string, content string) {
	if generateFiles[path] == "" {
		generateFiles[path] = `// This file is generated by cgui` + "\n\n" + content + "\n"
	} else {
		generateFiles[path] += content + "\n"
	}
}
